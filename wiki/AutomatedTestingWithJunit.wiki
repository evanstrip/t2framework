#summary A short tutorial about automated testing using T2
#labels Featured

= Automated Testing with T2 =

by Wishnu Prasetya

*Download and install [http://code.google.com/p/t2framework/ T2] first*;  it an automated testing utility for Java. It is a free.

==Example: a Sorted List class==

Let's consider the example below. It's a simple class that provides sorted lists.

{{{
package Examples ;

public class SortedList {

    private LinkedList<Comparable> s ;   // this will hold the list
    private Comparable max ;             // direct pointer to the largest element

    /**
     * A constructor to make an empty list.
     */
    public SortedList() { s = new LinkedList<Comparable>() ; }

    /**
     * Insert x into the list; maintain the list sorted, and relink max
     * accordingly.
     */
    public void insert(Comparable x) { ... }

    /**
     * Retrieve the max-element from the list. 
     */
    public Comparable get() { ... }
}
}}}

We'll fill in the code later.

When testing with T2 you don't write your test cases; T2 will internally generate them for you. You don't write oracles either. Instead, you write specifications. Specifications are more powerful and robust than oracles. And don't worry; we'll write our specifications in Java :)

The first specification we want to write is a class invariant. This is a predicate specifying legal states of the instances of our class. In this case we can expect 
that the list in the variable {{{s}}} will be sorted. This can be formally expressed in a class invariant. However, if you are a bit lazy you may choose to write a weak specification first, to be refined later when you are a bit further in the coding.

Ok, so let's write a class invariant. You write it simple as a method called classinv; it takes no argument and returns a boolean. I'll write a weak one:

{{{
private boolean classinv() {  return s.isEmpty() || s.contains(max) ; }
}}}

This method does not have any functionality. It just express a specification, and will be internally checked by T2 as it later checks your SortedList class.

I'll pretend to be a lazy programmer :), so for now I'll write no specification for "{{{insert}}}". However, I'll add some specification to "{{{get}}}".

The code for "{{{get}}}" is shown below, along with its specifications. A method can be specified by writing assertions. Note Java assertion is very powerful! You can express complicated things with it. IMPORTANT: assertions that specify pre-conditions of a method should be marked with {{{:"PRE"}}} marker; see below.

{{{
public Comparable get() {

   assert !s.isEmpty() : "PRE" ;  // Specifying pre-condition

   Comparable x = max ;
   s.remove(max) ;
   max = s.getLast() ;

   assert s.isEmpty() || x.compareTo(s.getLast()) >= 0 ; // Specifying post-condition

   return x ;
}
}}}

Here is now the full code of {{{SortedList}}}:

{{{
package Examples ;

public class SortedList {

    private LinkedList<Comparable> s ;   
    private Comparable max ;             

    public SortedList() { s = new LinkedList<Comparable>() ; }

    private boolean classinv() {  return s.isEmpty() || s.contains(max) ; }

    public void insert(Comparable x) { 
       int i = 0 ;
       for (Comparable y : s) {
          if (y.compareTo(x) > 0) break ;
          i++ ; }
      s.add(i,x) ;
      if (max==null || x.compareTo(max) < 0) max = x ;
   }

   public Comparable get() { 
      assert !s.isEmpty() : "PRE" ;  // Specifying pre-condition
      Comparable x = max ;
      s.remove(max) ;
      max = s.getLast() ;
      assert s.isEmpty() || x.compareTo(s.getLast()) >= 0 ; // Specifying post-condition
      return x ;
   }
}
}}}

==Now, let's test!==

===With console===

Now let's test the above class using T2. Let's first do this directly from the console:

{{{
> java -ea -cp MyT2DIR/bin/TTversion.jar;MyT2DIR/bin/* Sequenic.T2.Main Examples.SimpleSortedList
}}}

where MyT2DIR is the assumed directory where you have installed/unzipped T2. That's it! See it yourself if T2 can find some errors in the above class.

===T2 Report===

T2 will first report you its configuration, see below. Many of these parameters can be changed through options. Check the Manual.

{{{
** Invoked CONFIGURATION
** CUT = Examples.SimpleSortedList
** TYVAR0 = Sequenic.T2.OBJECT
** Pool = Sequenic.T2.Pool
** Base domain = Sequenic.T2.BaseDomainSmall
** Interface map = Sequenic.T2.InterfaceMap0
** Time-out = 20000
** Max. number of steps = 500
** Max. execution depth = 4
** Max. number of violations to look = 1
** Max. object depth (on creation) = 4
** Max. show depth = 5
** Max. array/collection size = 4
** Incl. Private = false
** Incl. Default = true
** Incl. Protected = true
** Incl. Static = true
** Incl. superclass members = true
** Incl. superclass classinvs = false
** Field update enabled = true
** Prob. of updating field = 0.1
** Prob. to generate NULL = 0.1
** Prob. to pass targetobj as param = 0.4
** Prob. of trying pool before constuctor = 0.7
}}} 

And it reports to you a summary of how many test-sequences it produces, and how many violations it finds:

{{{
** VIOLATIONS FOUND: 1
   1 assertion violations.
** number of irrelevant checks: 3.
   3 PRE violations.
** total number of traces: 5
** total execution steps : 16
** average trace lenght  : 3.0
** time: 172ms.
** average time per step: 10.0ms.
...
** Saving 1 traces...
}}}

And when violations are found, for each violation, the step were the violation is observed will be printed (and perhaps even some k-steps before it, depending on your setting), for example:

{{{
** Begin test sequence.
** STEP 0: creating target object.
** Calling constructor Examples.SimpleSortedList
** Resulting target object:
   (Examples.SimpleSortedList) @ 0
   s (LinkedList) @ 1
   max NULL
** STEP 1.
** Calling method insert with:
** Receiver: target-obj
** Arg [0:]
   (Integer) : 2
** State of target object now:
   (Examples.SimpleSortedList) @ 0
   s (LinkedList) @ 1
      [0] (Integer) : 2
   max (Integer) : 2
** STEP 2.
** Calling method insert with:
** Receiver: target-obj
** Arg [0:]
   (Integer) : -3
** State of target object now:
   (Examples.SimpleSortedList) @ 0
   s (LinkedList) @ 1
      [0] (Integer) : -3
      [1] (Integer) : 2
   max (Integer) : -3
** STEP 3.
** Calling method get_spec with:
** Receiver: target-obj
** State of target object now:
   (Examples.SimpleSortedList) @ 0
   s (LinkedList) @ 1
      [0] (Integer) : 2
   max (Integer) : 2
xx Assertion VIOLATED!
** Strack trace: java.lang.AssertionError: POST
...
** End test sequence
}}}


===We can also write JUnit tests with T2===

We can write Junit test methods as usual, however from inside those methods we call T2 to generate the the test sequences automatically for us. For example:

{{{
import org.junit.Test;

public class MyTest {

    @Test
    public void test1() {

        // Call T2, pass the full name of the target class to it:

        Sequenic.T2.Main.Junit(SortedList.class.getName()) ;
    }
}
}}}

Then just run the above test as usual with Junit; but additionally you need to:

  * Include {{{MyT2DIR/bin/T2version.jar}}} and {{{MyT2DIR/bin/*}}} in your class path
  * To turn on the {{{-ea}}} option of JVM (to enable Java assertions checking).

The above way of using T2 in JUnit is however not ideal. Every time you run it, T2 may randomly produce different test-sequences. You need to use a different function, namely {{{Main.GenAndReplayJunit}}} to prevent T2 from re-generating sequences in subsequent runs. Check the Manual.

==How does T2 works?==

T2 does not test the methods of a target class individually. Instead, it test the entire class. It randomly generates (lots of!) sequences of method calls and field updates to the target class; along with the parameters they need. As it goes, it checks the specifications in the target class. 

T2 itself has LOT's of options, e.g. to make it generate 20.000 test steps divided into sequences of length 10, and to report the first 8 violations (rather that the default 1), we change the above test method to:

{{{
@Test
public void test1() {
   Sequenic.T2.Main.Junit(
        SortedList.class.getName() 
        + " " 
        + "--nmax=20000 --lenexec=10 --violmax=8"  // pass T2 options here
   ) ;
}
}}}

There are options to do regression (replaying saved tests), generating test sequences in search-mode, etc etc. You'll have to check the manual.


===Using T2 in IDE===

Well, you don't need any special support. As explained above, you can use T2 as a library for writing JUnit test suites. So you can just use T2 in any IDE that supports Junit integration, like Eclipse or Netbeans. It is not necessary but highly recommended that you also install a plugin for your IDE that can measures the code coverage of your Junit tests; then you do the same with your T2 tests. E.g. for Eclipse you have the EclEmma plugin that can do this. 

===Combining automated and manual tests===

Yes, of course you can. In the above test example, you can add more test methods; some may be the traditional hand crafted tests.

===Further reading===

T2 Manual describes T2 options and other possibilities to customize it.


===End=== 