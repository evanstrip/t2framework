#summary One-sentence summary of this page.

= Automated Testing with JUnit =

by Wishnu Prasetya

Yes, you can do automated testing with JUnit! You need to download my[http://code.google.com/p/t2framework/ T2 utility] first. T2 is a powerful automated testing utility for Java. It is a free sowftware.

Download T2 jar first, and put it somewhere. We will use it as a normal Java library.

Let's consider the example below. It's a simple class that provides sorted lists.

{{{
public class SortedList {

    private LinkedList<Comparable> s ;   // this will hold the list
    private Comparable max ;             // direct pointer to the largest element

    /**
     * A constructor to make an empty list.
     */
    public SortedList() { s = new LinkedList<Comparable>() ; }

    /**
     * Insert x into the list; maintain the list sorted, and relink max
     * accordingly.
     */
    public void insert(Comparable x) { ... }

    /**
     * Retrieve the max-element from the list. 
     */
    public Comparable get() { ... }
}
}}}

We'll fill in the code later.

When testing with T2 you don't write your test cases; T2 will generate them for you. You don't write oracles either. Instead, you write specifications. Specifications are more powerful and robust than oracles. And don't worry; we'll write our specifications in Java :)

The first specification we want to write is a class invariant. This is a predicate specifying legal states of the instances of our class. In this case we can expect 
that the list in the variable {{{s}}} will be sorted. This can be formally expressed in a class invariant. However, if you are a bit lazy you may choose to write a weak specification first, to be refined later when you are a bit further in the coding.

Ok, so let's write a class invariant. You write it simple as a method called classinv; it takes no argument and returns a boolean. I'll write a weak one:

{{{
private boolean classinv() {  return s.isEmpty() || s.contains(max) ; }
}}}

This method does not have any functionality. It just express a specification, and will be internally checked by T2 as it later checks your SortedList class.

I'm a bit lazy, so I'll write no specification for "{{{insert}}}". Well ... maybe later. But not now. However, I'll add some specification to "{{{get}}}".

The code for "{{{get}}}" is shown below, along with its specifications. A method can be specified by writing assertions. Note Java assertion is very powerful! You can express complicated things with it. IMPORTANT: assertions that specify pre-conditions of a method should be marked with {{{:"PRE"}}} marker; see below.

{{{
public Comparable get() {

   assert !s.isEmpty() : "PRE" ;  // Specifying pre-condition

   Comparable x = max ;
   s.remove(max) ;
   max = s.getLast() ;

   assert s.isEmpty() || x.compareTo(s.getLast()) >= 0 ; // Specifying post-condition

   return x ;
}
}}}

Here is the full code of {{{SortedList}}}:

{{{
public class SortedList {

    private LinkedList<Comparable> s ;   
    private Comparable max ;             

    public SortedList() { s = new LinkedList<Comparable>() ; }

    private boolean classinv() {  return s.isEmpty() || s.contains(max) ; }

    public void insert(Comparable x) { 
       int i = 0 ;
       for (Comparable y : s) {
          if (y.compareTo(x) > 0) break ;
          i++ ; }
      s.add(i,x) ;
      if (max==null || x.compareTo(max) < 0) max = x ;
   }

   public Comparable get() { 
      assert !s.isEmpty() : "PRE" ;  // Specifying pre-condition
      Comparable x = max ;
      s.remove(max) ;
      max = s.getLast() ;
      assert s.isEmpty() || x.compareTo(s.getLast()) >= 0 ; // Specifying post-condition
      return x ;
   }
}
}}}

Now let's test the above class. We'll just have to write our usual Junit test; however inside the test we will call T2 to generate the test cases for us. Here is my test:

{{{
import org.junit.Test;

public class MyTest {

    @Test
    public void test1() {
        Sequenic.T2.Main.Junit(SortedList.class.getName()) ;
    }
}
}}}

Just run this test as usual with Junit; but you do have to turn on the {{{-ea}}} option (to enable Java assertions). See it yourself if T2 can find some errors in the above class.

That's it!!

===How does T2 works?===

T2 does not test the methods of a target class individually. Instead, it test the entire class. It randomly generates sequences of method calls and field updates to the target class; along with the parameters they need. As it goes, it checks the specifications in the target class. 

T2 itself has LOT's of options, e.g. options to do regression (replaying saved tests), generating test sequences in search-mode, etc. You'll have to check the manual.

===Using T2 in IDE===

Well, you don't need any special support. As explained above, you can use T2 as a library, and call it from inside your Junit tests. So you can just use T2 in any IDE that supports Junit integration. If your IDE has a plugin that can measures code coverage of your Junit tests, then you do the same with your T2 tests.

===Combining automated and manual tests===

Yes, of course you can. In the above test example, you can add more test methods; some may be the traditional hand crafted tests.

===End=== 